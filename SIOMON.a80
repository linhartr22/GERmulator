;*****
;* Equates
;*
NUL         EQU     $00 
BEL         EQU     $07 
BS          EQU     $08 
HT          EQU     $09 
LF          EQU     $0A 
FF          EQU     $0C 
CR          EQU     $0D 
ESC         EQU     $1B 

SIODATA     EQU     $80 

SIOST       EQU     $81 
SIOSTTXRDY  EQU     $01 
SIOSTRXRDY  EQU     $02 
SIOSTTXE    EQU     $04 

SIOMO       EQU     $81 
SIOMOS1     EQU     $40 
SIOMOS15    EQU     $80 
SIOMOS2     EQU     $C0 
SIOMOPE     EQU     $20 
SIOMOPEN    EQU     $10 
SIOMOC5     EQU     $00 
SIOMOC6     EQU     $04 
SIOMOC7     EQU     $08 
SIOMOC8     EQU     $0C 
SIOMOBS     EQU     $00 
SIOMOB1X    EQU     $01 
SIOMOB16X   EQU     $02 
SIOMOB64X   EQU     $03 
SIOMOI      EQU     siomos1+siomoc8+siomob16x 

SIOCMD      EQU     $81 
SIOCMDTXEN  EQU     $01 
SIOCMDDTR   EQU     $02 
SIOCMDRXEN  EQU     $04 
SIOCMDER    EQU     $10 
SIOCMDRTS   EQU     $20 
SIOCMDIR    EQU     $40 
SIOCMDI     EQU     siocmddtr+siocmdrts+siocmdtxen+siocmder 

;*****
;* IRQ Vectors
            .ORG    $0000 
            JMP     init ; RST 0, RESET
            .ORG    $0008 
            JMP     init ; RST 1
            .ORG    $0010 
            JMP     init ; RST 2
            .ORG    $0018 
            JMP     init ; RST 3
            .ORG    $0020 
            JMP     init ; RST 4
            .ORG    $0028 
            JMP     init ; RST 5
            .ORG    $0030 
            JMP     init ; RST 6
            .ORG    $0038 
            JMP     init ; RST 7

;*****
;* Init
;*
            .ORG    $0100 

INIT:       LXI     sp,spinit ; Init SP

SIOINIT:    SUB     a ; Clear SIO Init Sequence
            OUT     siomo 
            OUT     siomo 
            OUT     siomo 
            MVI     a,siocmdir ; Send SIO Command Internal Reset
            OUT     siocmd 
            MVI     a,siomoi ; Send SIO Mode Instruction
            OUT     siomo 
            MVI     a,siocmdi ; Send SIO Command Instruction
            OUT     siocmd 

MONINIT:    LXI     h,grtmsg ; Display Greet Message
            CALL    soutstr 

;*****
;* Main
;*
MAIN:       LXI     h,clmsg ; Display Prompt
            CALL    soutstr 
            MVI     a,siocmdi+siocmdrxen ; Set SIO RX Enable
            OUT     siocmd 
            LXI     h,clbuf ; Get SIO Command Line Buffer Pointer
            LXI     b,clbufe-clbuf ; Get SIO Command Line Buffer Size (Zeros B - Size in C)
            CALL    sinstr ; Get SIO Command Line Buffer
            MVI     a,siocmdi ; Clear SIO RX Enable
            OUT     siocmd 

PARSE:      LXI     h,clbuf ; Get Command Line Buffer Pointer
            CALL    str2upr ; Make Upper Case
            MOV     a,m ; Get First Character
            INX     h ; Inc Buffer Pointer
            SHLD    clbufptr ; Save Buffer Pointer
            CPI     '?' 
            JZ      help ; Display Help
            CPI     'D' 
            JZ      dump 
            CPI     'E' 
            JZ      entr 
            CPI     'G' 
            JZ      goto 
ERROR:      LXI     h,errmsg ; Display Error
            CALL    soutstr 
            JMP     main ; Next Command
HELP:       LXI     h,hlpmsg ; Display Help
            CALL    soutstr 
            JMP     main ; Next Command
DUMP:       CALL    s2w ; Get Dump Begin Address
            JZ      error ; No Digits Found
            SHLD    clbufptr ; Save Buffer Pointer
            MVI     a,$0F0 ; Start on 16 Byte Boundry
            ANA     e 
            MOV     e,a 
            XCHG     ; Save Dump Begin Address
            SHLD    dumpb 
            XCHG     ; Restore Buffer Pointer
            CALL    s2w ; Get Dump End Address
            JZ      error ; No Digits Found
            SHLD    clbufptr ; Save Buffer Pointer
            MVI     a,$0F ; End on 16 Byte Boundry
            ORA     e 
            MOV     e,a 
            XCHG     ; Save Dump End Address
            SHLD    dumpe 
            LXI     h,dumphd ; Display Dump Header
            CALL    soutstr 
DUMPNL:     LHLD    dumpb ; Get Address Pointer
            MOV     A,H ; Display Address High Byte
            CALL    southexb 
            MOV     a,l ; Display Address Low Byte
            CALL    southexb 
            MVI     a,' ' ; Display Space
            CALL    soutc 
            MVI     b,16 ; Display 16 Bytes
DUMPBYTE:   MOV     a,m ; Get Byte
            INX     h ; Inc Address Pointer
            CALL    southexb ; Display Byte
            MVI     a,' ' 
            CALL    soutc 
            DCR     b ; Display Another Byte?
            JNZ     dumpbyte ; Yes
            LHLD    dumpb ; Get Address Pointer
            MVI     b,16 ; Display 16 Characters
DUMPCHAR:   MOV     a,m ; Get Character
            INX     h ; Inc Address Pointer
            CPI     ' ' ; Printable Character?
            JC      dumpchar1 ; No
            CPI     $80 
            JC      dumpchar2 ; Yes
DUMPCHAR1:  MVI     a,'.' ; Non-Printable Character
DUMPCHAR2:  CALL    soutc ; Display Character
            DCR     b ; Display Another Character?
            JNZ     dumpchar ; Yes
            CALL    soutcrlf ; Display CRLF
            SHLD    dumpb ; Save Dump Begin Address
            XCHG     
            LHLD    dumpe ; Get Dump End Address
            CALL    cmphlde ; Dump End >= Dump Begin
            JNC     dumpnl ; Yes, Dump Next Line
            JMP     main ; No, Next Command
ENTR:       JMP     main ; Next Command
GOTO:       JMP     main ; Next Command

;*****
;* Library
;*
            .ORG    $1800 

;=====
;= Serial Output Character in Acc
;= Modifies: None
SOUTC:      PUSH    psw ; Save Char
            IN      siost ; SIO Ready to Tx?
            ANI     siosttxe 
            JZ      soutc ; No, Keep Waiting
            POP     psw ; Restore Char
            OUT     siodata ; Output Char to SID Data Port
SOUTCX:     RET      ; Done

;=====
;= Serial Output String at HL, Null terminated
;= Modifies: AF, HL
SOUTSTR:    MOV     a,m ; Get Char from Buffer
            ORA     a ; Null?
            RZ      soutstrx ; Yes, Exit
            CALL    soutc ; No, Serial Output Char
            INX     h ; Inc Buffer Pointer
            JMP     soutstr ; Get Next Char

;=====
;= Serial Output Hex Byte in Acc
;= Modifies AF
SOUTHEXB:   PUSH    psw ; Save Byte
            RRC      ; Get Upper Nibble
            RRC      
            RRC      
            RRC      
            ANI     $0F ; Mask off Upper Nibble
            ADI     '0' ; Convert to ASCII
            CPI     ':' ; Hex Adjust?
            JC      southexb1 ; No
            ADI     'A'-':' ; Yes
SOUTHEXB1:  CALL    soutc ; Serial Output Char
            POP     psw ; Restore Char
            ANI     $0F ; Mask off Upper Nibble
            ADI     '0' ; Convert to ASCII
            CPI     ':' ; Hex Adjust?
            JC      southexb2 ; No
            ADI     'A'-':' ; Yes
SOUTHEXB2:  JMP     soutc ; Serial Output Char

;=====
;= Serial Input String at HL, B=Count, C=Length
;= Set B to 0 when calling
;= Modifies AF, BC, DE, HL
SINSTR:     PUSH    h ; Save Registers
            PUSH    b 
SINSTRCB:   MVI     m,0 ; Clear Buffer
            DCR     c 
            JNZ     sinstrcb 
            POP     b ; Restore Registers
            POP     h 
SINSTRGC:   CALL    sinc ; Get Character
            MOV     d,a ; Save Character
            CPI     cr ; Carriage Return?
            JZ      sinstrx ; Yes, Exit
            CPI     bs ; Backspace?
            JZ      sinstrbs ; Yes, Backspace
            CPI     ' ' ; Printable Character?
            JC      sinstr ; No, Ignore Character
            MOV     a,b ; Character Counter = Buffer Size?
            CMP     c 
            JZ      sinstr ; Yes, Ignore Character
            MOV     a,d ; Restore Character
            MOV     m,a ; No, Save Character in Buffer
            INX     h ; Inc Buffer Pointer
            INR     b ; Inc Buffer Count
SINSTRECHO: CALL    soutc ; Echo Character
            JMP     sinstr ; Get Next Character
SINSTRBS:   MOV     a,b ; Count = 0?
            ORA     a 
            JZ      sinstr ; Yes, Ignore Backspace
            DCX     h ; Dec Buffer Pointer
            DCR     b ; Dec Character Count
            MVI     m,' ' ; Erase Character in Buffer
            MOV     a,d ; Restore Character
            JMP     sinstrecho ; Echo Character
SINSTRX:    MVI     m,nul ; Null Terminate Buffer
            JMP     soutcrlf ; Send CRLF


;=====
;= Serial Input Character to Acc
;= Modifies AF
SINC:       IN      siost ; Character Ready?
            ANI     siostrxrdy 
            JZ      sinc ; No, Keep Waiting
            IN      siodata ; Input Character
            ANI     $7F ; Make 7-bit ASCII
            RET      

;=====
;= String at HL to Upper Case
;= Modifies AF
STR2UPR:    PUSH    h ; Save String Pointer
STR2UPRN:   MOV     a,m ; Character = Null?
            ORA     a 
            JZ      str2uprx ; Yes, Exit
            CPI     'a'-1 ; Character Lower Case?
            JC      str2upr1 ; No
            CPI     'z'+1 
            JNC     str2upr1 ; No
            MVI     a,0-('a'-'A') ; Yes, Make Upper Case
            ADD     m 
            MOV     m,a 
STR2UPR1:   INX     h ; Inc Pointer
            JMP     str2uprn ; Check Next Character
STR2UPRX:   POP     h ; Restore String Pointer
            RET      

;=====
;= Parse Word to DE from String at HL
;= Returns HL Pointing to Next Non-Digit Character
;= Returns Z Digit Found Flag
;= Modifies HL, DE, BC, AF
S2W:        LXI     d,0 ; Clear Word
            MOV     c,e ; Clear Digit Found Flag
S2WNC:      MOV     a,m ; Get Character
            ORA     a ; Character = Nul?
            JZ      s2wx ; Yes, Exit
            SUI     '0' ; Character = Digit?
            JC      s2wdl ; No, Process Delimeter
            CPI     10 
            JC      s2wdg ; Yes, Process Digit
            SUI     'A'-'9'-1 
            JC      s2wdl ; No, Process Delimeter
            CPI     16 
            JNC     s2wdl ; Yes, Process Delimeter
S2WDG:      MVI     c,-1 ; Set Digit Found Flag
            PUSH    psw ; Save Digit
            MVI     b,4 ; Shift DE Left 4 Bits
S2WDG1:     ORA     a ; Clear Carry
            MOV     a,e 
            RAL      
            MOV     e,a 
            MOV     a,d 
            RAL      
            MOV     d,a 
            DCR     b ; Again?
            JNZ     s2wdg1 ; Yes
            POP     psw ; Restore Digit
            ORA     e ; Save Digit
            MOV     e,a 
S2WINC:     INX     h ; Inc String Pointer
            JMP     s2wnc ; Process Next Character
S2WDL:      MOV     a,c ; Digit Found?
            ORA     a 
            JZ      s2winc ; No, Keep Looking
S2WX:       MOV     a,c ; Set Z to Digit Found Flag
            ORA     a 
            RET      

;=====
;* Serial Output CRLF
;* Modifies AF
SOUTCRLF:   MVI     A,cr ; Display CR
            CALL    SOUTC 
            MVI     a,lf ; Display LF
            JMP     soutc 

;=====
;* Compare HL to DE
;* Modifies AF
CMPHLDE:    MOV     a,l ; Subtract DE from HL
            SUB     e 
            MOV     a,h 
            SBB     d 
            RET      

;*****
;* String Constants
;*
            .ORG    1E00H 

GRTMSG:     DB      cr,lf,lf,'GERmon v1.0',bel 
            DB      '   Roger D. Linhart',bel 
            DB      '   Nov 2018',bel,cr,lf,lf 
            DB      nul 
CLMSG:      DB      '? ' 
            DB      nul 
ERRMSG:     DB      'Error',cr,lf 
            DB      nul 
HLPMSG:     DB      cr,lf 
            DB      'Commands',cr,lf 
            DB      '========',cr,lf 
            DB      'D bbbb eeee <enter>  ' 
            DB      'Display Memory',cr,lf 
            DB      'E aaaa <enter>       ' 
            DB      'Edit Memory',cr,lf 
            DB      'G aaaa <enter>       ' 
            DB      'Execute (GoTo) Memory',cr,lf 
            DB      nul 
DUMPHD:     DB      '     00 01 02 03 04 05 06 07 08 ' 
            DB      '09 0A 0B 0C 0D 0E 0F ' 
            DB      '0123456789ABCDEF',cr,lf 
            DB      nul 

;*****
;* RAM
;*
            .ORG    8000h 

CLBUF:      DS      12 ; Command Line Buffer (String - Null Delimited)
CLBUFE:     DB      0 ; Command Line Buffer End and Space for Null Delimeter
CLBUFPTR:   DW      0 ; Command Line Buffer Pointer
DUMPB:      DW      0 ; Dump Address Begin
DUMPE:      DW      0 ; Dump Address End

;*****
;* STACK
;*
            .ORG    0FE00h 

            DS      100h 
SPINIT      EQU     $ 










